// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod firmoto {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OPERATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OPERATION_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATION_TYPE: [OperationType; 3] = [
  OperationType::GPIO,
  OperationType::I2C,
  OperationType::SPI,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperationType(pub i8);
#[allow(non_upper_case_globals)]
impl OperationType {
  pub const GPIO: Self = Self(0);
  pub const I2C: Self = Self(1);
  pub const SPI: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GPIO,
    Self::I2C,
    Self::SPI,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::GPIO => Some("GPIO"),
      Self::I2C => Some("I2C"),
      Self::SPI => Some("SPI"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OperationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OperationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for OperationType {
    type Output = OperationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for OperationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OperationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OperationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SUB_OPERATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SUB_OPERATION_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SUB_OPERATION_TYPE: [SubOperationType; 4] = [
  SubOperationType::SPI_WRITE_U8,
  SubOperationType::SPI_READ_U8,
  SubOperationType::SPI_READ_U16,
  SubOperationType::SPI_READ_N,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SubOperationType(pub i8);
#[allow(non_upper_case_globals)]
impl SubOperationType {
  pub const SPI_WRITE_U8: Self = Self(0);
  pub const SPI_READ_U8: Self = Self(1);
  pub const SPI_READ_U16: Self = Self(2);
  pub const SPI_READ_N: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPI_WRITE_U8,
    Self::SPI_READ_U8,
    Self::SPI_READ_U16,
    Self::SPI_READ_N,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SPI_WRITE_U8 => Some("SPI_WRITE_U8"),
      Self::SPI_READ_U8 => Some("SPI_READ_U8"),
      Self::SPI_READ_U16 => Some("SPI_READ_U16"),
      Self::SPI_READ_N => Some("SPI_READ_N"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SubOperationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SubOperationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for SubOperationType {
    type Output = SubOperationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for SubOperationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SubOperationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SubOperationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VALUE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VALUE_TYPE: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE_TYPE: [ValueType; 12] = [
  ValueType::U8,
  ValueType::U16,
  ValueType::U32,
  ValueType::U64,
  ValueType::I8,
  ValueType::I16,
  ValueType::I32,
  ValueType::I64,
  ValueType::F32,
  ValueType::F64,
  ValueType::String,
  ValueType::Boolean,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ValueType(pub i8);
#[allow(non_upper_case_globals)]
impl ValueType {
  pub const U8: Self = Self(0);
  pub const U16: Self = Self(1);
  pub const U32: Self = Self(2);
  pub const U64: Self = Self(3);
  pub const I8: Self = Self(4);
  pub const I16: Self = Self(5);
  pub const I32: Self = Self(6);
  pub const I64: Self = Self(7);
  pub const F32: Self = Self(8);
  pub const F64: Self = Self(9);
  pub const String: Self = Self(10);
  pub const Boolean: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::U8,
    Self::U16,
    Self::U32,
    Self::U64,
    Self::I8,
    Self::I16,
    Self::I32,
    Self::I64,
    Self::F32,
    Self::F64,
    Self::String,
    Self::Boolean,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::U8 => Some("U8"),
      Self::U16 => Some("U16"),
      Self::U32 => Some("U32"),
      Self::U64 => Some("U64"),
      Self::I8 => Some("I8"),
      Self::I16 => Some("I16"),
      Self::I32 => Some("I32"),
      Self::I64 => Some("I64"),
      Self::F32 => Some("F32"),
      Self::F64 => Some("F64"),
      Self::String => Some("String"),
      Self::Boolean => Some("Boolean"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ValueType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ValueType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for ValueType {
    type Output = ValueType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ValueType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ValueType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ValueType {}
pub enum OperationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Operation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operation<'a> {
  type Inner = Operation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Operation<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OP_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SUB_OP_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ARGS: flatbuffers::VOffsetT = 10;
  pub const VT_RETVAL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Operation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OperationArgs<'args>
  ) -> flatbuffers::WIPOffset<Operation<'bldr>> {
    let mut builder = OperationBuilder::new(_fbb);
    if let Some(x) = args.retval { builder.add_retval(x); }
    if let Some(x) = args.args { builder.add_args(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_sub_op_type(args.sub_op_type);
    builder.add_op_type(args.op_type);
    builder.finish()
  }

  pub fn unpack(&self) -> OperationT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let op_type = self.op_type();
    let sub_op_type = self.sub_op_type();
    let args = self.args().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let retval = self.retval().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    OperationT {
      name,
      op_type,
      sub_op_type,
      args,
      retval,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Operation::VT_NAME, None)}
  }
  #[inline]
  pub fn op_type(&self) -> OperationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OperationType>(Operation::VT_OP_TYPE, Some(OperationType::GPIO)).unwrap()}
  }
  #[inline]
  pub fn sub_op_type(&self) -> SubOperationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SubOperationType>(Operation::VT_SUB_OP_TYPE, Some(SubOperationType::SPI_WRITE_U8)).unwrap()}
  }
  #[inline]
  pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>>>(Operation::VT_ARGS, None)}
  }
  #[inline]
  pub fn retval(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>>>(Operation::VT_RETVAL, None)}
  }
}

impl flatbuffers::Verifiable for Operation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<OperationType>("op_type", Self::VT_OP_TYPE, false)?
     .visit_field::<SubOperationType>("sub_op_type", Self::VT_SUB_OP_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>>>("args", Self::VT_ARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>>>("retval", Self::VT_RETVAL, false)?
     .finish();
    Ok(())
  }
}
pub struct OperationArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub op_type: OperationType,
    pub sub_op_type: SubOperationType,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>>,
    pub retval: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>>,
}
impl<'a> Default for OperationArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperationArgs {
      name: None,
      op_type: OperationType::GPIO,
      sub_op_type: SubOperationType::SPI_WRITE_U8,
      args: None,
      retval: None,
    }
  }
}

pub struct OperationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OperationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operation::VT_NAME, name);
  }
  #[inline]
  pub fn add_op_type(&mut self, op_type: OperationType) {
    self.fbb_.push_slot::<OperationType>(Operation::VT_OP_TYPE, op_type, OperationType::GPIO);
  }
  #[inline]
  pub fn add_sub_op_type(&mut self, sub_op_type: SubOperationType) {
    self.fbb_.push_slot::<SubOperationType>(Operation::VT_SUB_OP_TYPE, sub_op_type, SubOperationType::SPI_WRITE_U8);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operation::VT_ARGS, args);
  }
  #[inline]
  pub fn add_retval(&mut self, retval: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operation::VT_RETVAL, retval);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OperationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Operation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Operation");
      ds.field("name", &self.name());
      ds.field("op_type", &self.op_type());
      ds.field("sub_op_type", &self.sub_op_type());
      ds.field("args", &self.args());
      ds.field("retval", &self.retval());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OperationT {
  pub name: Option<String>,
  pub op_type: OperationType,
  pub sub_op_type: SubOperationType,
  pub args: Option<Vec<ValueT>>,
  pub retval: Option<Vec<ValueT>>,
}
impl Default for OperationT {
  fn default() -> Self {
    Self {
      name: None,
      op_type: OperationType::GPIO,
      sub_op_type: SubOperationType::SPI_WRITE_U8,
      args: None,
      retval: None,
    }
  }
}
impl OperationT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Operation<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let op_type = self.op_type;
    let sub_op_type = self.sub_op_type;
    let args = self.args.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let retval = self.retval.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Operation::create(_fbb, &OperationArgs{
      name,
      op_type,
      sub_op_type,
      args,
      retval,
    })
  }
}
pub enum ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Value<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
  type Inner = Value<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Value<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALTYPE: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Value { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ValueArgs<'args>
  ) -> flatbuffers::WIPOffset<Value<'bldr>> {
    let mut builder = ValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_valtype(args.valtype);
    builder.finish()
  }

  pub fn unpack(&self) -> ValueT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let valtype = self.valtype();
    let value = self.value().map(|x| {
      x.to_string()
    });
    ValueT {
      name,
      valtype,
      value,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Value::VT_NAME, None)}
  }
  #[inline]
  pub fn valtype(&self) -> ValueType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ValueType>(Value::VT_VALTYPE, Some(ValueType::U8)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Value::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Value<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<ValueType>("valtype", Self::VT_VALTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ValueArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub valtype: ValueType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValueArgs {
      name: None,
      valtype: ValueType::U8,
      value: None,
    }
  }
}

pub struct ValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_NAME, name);
  }
  #[inline]
  pub fn add_valtype(&mut self, valtype: ValueType) {
    self.fbb_.push_slot::<ValueType>(Value::VT_VALTYPE, valtype, ValueType::U8);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Value<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Value");
      ds.field("name", &self.name());
      ds.field("valtype", &self.valtype());
      ds.field("value", &self.value());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ValueT {
  pub name: Option<String>,
  pub valtype: ValueType,
  pub value: Option<String>,
}
impl Default for ValueT {
  fn default() -> Self {
    Self {
      name: None,
      valtype: ValueType::U8,
      value: None,
    }
  }
}
impl ValueT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Value<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let valtype = self.valtype;
    let value = self.value.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Value::create(_fbb, &ValueArgs{
      name,
      valtype,
      value,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Operation`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_operation_unchecked`.
pub fn root_as_operation(buf: &[u8]) -> Result<Operation, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Operation>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Operation` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_operation_unchecked`.
pub fn size_prefixed_root_as_operation(buf: &[u8]) -> Result<Operation, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Operation>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Operation` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_operation_unchecked`.
pub fn root_as_operation_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Operation<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Operation<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Operation` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_operation_unchecked`.
pub fn size_prefixed_root_as_operation_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Operation<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Operation<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Operation and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Operation`.
pub unsafe fn root_as_operation_unchecked(buf: &[u8]) -> Operation {
  unsafe { flatbuffers::root_unchecked::<Operation>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Operation and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Operation`.
pub unsafe fn size_prefixed_root_as_operation_unchecked(buf: &[u8]) -> Operation {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Operation>(buf) }
}
#[inline]
pub fn finish_operation_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Operation<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_operation_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Operation<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Firmoto

